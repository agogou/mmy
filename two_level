//
//  2-level-mixing SIR model
//
//

#include<stdio.h>    /* printf */
#include<stdlib.h>   /* abs */
#include<math.h>
#include<time.h>
#include <stdbool.h>

double gamratio(double x1,double x2,double y1,double y2);
void award(int*A,int*B,int**C,int**D,int*A2,int*B2,int**C2,int**D2,int n,int m);
int check(int **lpropc,int **gpropc,int *ldegree ,int *gdegree,int n);
void dohits(int **lpropc,int **gpropc,int *ldegree,int *gdegree,int start,int n,int *hit);
long int factorial(int a);
int sum(int *pa, int num_elements);
long int choose(int n,int k);
double randn();
double randomInteger01(void);
int randomInteger(void);
int randomIntegern(int n);
void loglikelihood(double *result,int lamdaL,int lamdaG,int **gpropc,int **lpropc,int*ldegree,int*gdegree,int *locsize,int n,int pop);
void display_mat_deg(int ** c, int * d, int n);

int main()
{
    int n=50,pop=1000,m=17;   /*m=The maximum group size*/
    int i,ii,j,jj,k,kk,*grsize,*orio,*integ,*dg,*dl,*lpropd,*gpropd,*linf;
    int Nllinks,lsum, hous;
    double propl,propg,numer[2],denom[2],u,up,acc;
    double lambdaL, lambdaG,cholprob,slamL,slamG,prratio;  /*,lthresh, gthresh*/
    long double infper;
    int burn=10000,samgap=50,samsize=10000,sumdat,looplen,counter,p;
    bool done;
    int **dat, **gpropc,**lpropc,**cg,**cl,**who;
    FILE *fd;
    /*n is the final size of a 2-level-mixing SIR model*/
     

    /*dynamic allocation of memory for c*/
    dat= (int **)malloc(m * sizeof(int *));  /*dimiourgia dunamikou pinaka dat */
    for (i=0; i<n; i++)
    {
        dat[i] = (int *)malloc(m * sizeof(int));
    }
    if(dat== NULL)
    {
        printf("Not enough memory\n");
        exit(1);
    }
    
    /*dynamic allocation for the c proposal propc*/
    gpropc=(int **)malloc(n * sizeof(int *)); /*dimiourgia dunamikou pinaka propc */
    for (i=0; i<n; i++)
    {
        gpropc[i] = (int *)malloc(n * sizeof(int));
    }
    if(gpropc== NULL)
    {
        printf("Not enough memory\n");
        exit(1);
    }

    lpropc=(int **)malloc(n * sizeof(int *));  /*dimiourgia dunamikou pinaka cg */
    for (i=0; i<n; i++)
    {
        lpropc[i] = (int *)malloc(m * sizeof(int));
    }
    if(lpropc== NULL)
    {
        printf("Not enough memory\n");
        exit(1);
    }

    cl=(int **)malloc(n * sizeof(int *));  /*dimiourgia dunamikou pinaka cg */
    for (i=0; i<n; i++)
    {
        cl[i] = (int *)malloc(m * sizeof(int));
    }
    if(cl== NULL)
    {
        printf("Not enough memory\n");
        exit(1);
    }

    cg=(int **)malloc(n * sizeof(int *));  /*dimiourgia dunamikou pinaka cg */
    for (i=0; i<n; i++)
    {
        cg[i] = (int *)malloc(n * sizeof(int));
    }
    if(cg== NULL)
    {
        printf("Not enough memory\n");
        exit(1);
    }

    who=(int **)malloc(n * sizeof(int *));  /*dimiourgia dunamikou pinaka cg */
    for (i=0; i<n; i++)
    {
        who[i] = (int *)malloc(m * sizeof(int));
    }
    if(who== NULL)
    {
        printf("Not enough memory\n");
        exit(1);
    }


    integ=(int *) malloc((n+1)*sizeof(int));
    orio=(int *) malloc(m*sizeof(int));
    grsize=(int *) malloc(n*sizeof(int));
    dg=(int *) malloc((n)*sizeof(int));
    dl=(int *) malloc((n)*sizeof(int));
    lpropd=(int *) malloc((n)*sizeof(int));
    gpropd=(int *) malloc((n)*sizeof(int));
    linf=(int *) malloc((n)*sizeof(int));

    /*opens the file for saving results*/
    if((fd=fopen("arxeio2.dat","w"))==NULL)   
        printf("File could not opened\n"); 
    
    /*fill the c and d matrices with 0's*/
    for(i=0; i<m; i++)       /* mhdenismos tou c kai tou c */
    {
        for(j=0; j<m; j++)
           {
		 dat[i][j]=0;   
	   }
     }    
    
    infper = 1;
    dat[1][3]=1;       
    dat[0][4]=1;   /* dat(k,l) is the number of households of */
    dat[2][5]=1;   /* size(=initial number of susceptibles) l */
    dat[0][6]=3;   /* with k ultimately infected individuals  */
    dat[4][6]=1;
    dat[6][6]=1;
    dat[0][7]=2;
    dat[6][7]=1;
    dat[0][8]=2;
    dat[0][9]=1;
    dat[0][12]=1;
    dat[0][13]=1;
    dat[0][14]=1;
    dat[0][17]=1;
    sumdat = 0;  /*Count the number of infected households*/
   
    for(i=0; i<m; i++)       
    {
        for(j=i; j<m; j++)
        {
	      sumdat=sumdat+dat[i][j];  
	}
    }  
    /*Create the group size of each individual*/          
    k = 0;       
    for(i=0; i<m; i++)       
    {
         for(j=i; j<m; j++)
         { 
              kk=(i+1)* dat[i][j];  /* an den mpei to +1 tote to kk mhdenizete gia i=0*/
	      for(ii=0; ii<kk; ii++)
	      {
	           grsize[k] = j+1; /* +1 gia ton idio logo */
   		   k=k+1;
              }
	 }
    }


   /*Create the limits of the sums*/
   
   for (i=0; i<m; i++) /*initialize*/
   {
        orio[i]=0;
   }

   for(i=0; i<m; i++)       
   {
        for(j=i; j<m; j++)
        {
             orio[i] = orio[i] + i*dat[i][j];
	}
	if (i>1)
	{
             orio[i] = orio[i] + orio[i-1];   /*na elenksw an to -1 deimiourgei problhma iga i=0*/
	}
   }
   for (i=0; i<n+1; i++)
   {
        integ[i] = i;
   }
   /*Create the household status for each individual */

   for (i=0; i<n; i++)
   {
        for (ii=0; ii<m; ii++)
	{
	     if (i<=orio[ii])
	     {
	          hous=(i+1-orio[ii]-1)/ii+1;
	          for(j=0; i<ii; i++)
		  {
		       who[i][j]=orio[ii]+((ii+1)*hous)+j+1;
		  }
		  jj=ii+1;
	          for(j=jj; j<m; j++)
		  {
		       who[i][j]=0; /*So everybody can be regarded as infected*/
	          }
	     }
	}
   }

   /*Count the local final size*/
   for(i=0; i<n; i++)
   {
        lsum=0;
        for(j=0; j<m; i++)
	{
	     if(who[i][j]>0)
	     {
	          lsum=lsum+1;
	     }
	}
	linf[i]=lsum;  /*The final size in i's household*/
	for(j=0;j<m; i++)
	{
	}
   }
/*Count the total number of potential local links, that doesn't include the
contact with yourself, like in the global case*/
   lsum=0;
   for(i=1; i<m; i++)
   {
        for(j=i; j<m; j++)
	{
	     lsum=lsum+i*(i)*(dat[i][j]);
	}
   }
   Nllinks = lsum;
     
   slamL = 0.01;      /*Initialise standard deviation of lambdas*/
   slamG = 0.01;
   lambdaL = 0.001;   /*Initialise parameters*/
   lambdaG = 0.001;
  /* lthresh = 0.5;      
   gthresh = 0.8; */
   cholprob = 0.5;    /*cholprob=lthresh/(lthresh+gthresh)The probability of choosing local*/

       /*Initialise the graph*/ 
   
  
   for (i=0; i<n; i++)
   {    
        dl[i]=0;
        dg[i]=0;
        for (j=0; j<n; j++)  
        {
		cg[i][j]=0;
        	cl[i][j]=0; 
   	}
   }
   for (i=0; i<n-1; i++)
   {
   	cg[i][0]=i+2;   /*At the biggining global links only*/
        dg[i]=1;
   }
   
   burn=5000000;
   samgap=200;
   samsize=10000;
   burn = burn-(2*burn);
   looplen=samgap*samsize;

   for(counter=burn; counter<=looplen; counter++)
   {
        propl=randn(lambdaL,slamL);
        propl=fabs(propl);
        propg=randn(lambdaG,slamG);
        propg=fabs(propg);
        loglikelihood(numer,propl,propg,cl,cg,dl,dg,grsize,n,pop);
        if(numer[1]==1)   
        {    
	     loglikelihood(denom,lambdaL,lambdaG,cg,cl,dl,dg,grsize,n,pop);
	     prratio= gamratio(propl,propg,lambdaL,lambdaG);
	     acc= prratio+exp(numer[0]-denom[0]);
             u=randomInteger01();
             if(log(u)<acc)
	     { 
	         lambdaL=propl;  /*Update the two infection rates*/
                 lambdaG=propg;	
             }
        }    

        /* κανουμε update του γραφηματος */
        p=randomInteger();   /* zhtame ena arithmo 1 h 2 */
        if(p==1)             /*we pick to add either local or global*/
        {
             up=randomInteger01();  
             if((up<cholprob)&&(Nllinks-(sum(dl,n))>0))   /*Choose to add local*/  
	     {
    	          k=randomIntegern(Nllinks-(sum(dl,n)));
	          j=orio[0]+1;
	          k=0;
	          do
                  {	
	               k=k+(linf[j]-1)-dl[j];               
   	               j=j+1;
                  }while(k+(linf[j]-1)-dl[j]<i);
                  do
                  {            /*Now j is the guy from where the (local)link will emanate*/
	               done=true;
	               k=randomIntegern(Nllinks-sum(dl,n));
	               if (k==j)
		       {
		            done=false;
		       }
		       else if(dl[j]>=1)
		       {
		            for(i=0; i<dl[j]; i++)
	 		   {
	 		        if(cl[j][i]==k)
	 		        {
	 			     done=false;
	 	                }
	 		    }
	 	      }     
                  }while(done==false);
                  /*Set up the proposed new graph*/
                   award(lpropd,gpropd,gpropc,lpropc,dl,dg,cg,cl,n,m);

 	          lpropd[j] = lpropd[j] +1;  /*Register the extra link*/     
 	          lpropc[j][dl[j]+1]=k;   /*  Draw the extra link*/

	    
	          /* numer=loglikelihood(lambdaL,lambdaG,lpropc,gpropc,lpropd,gpropd,infper) */
                  if(check(lpropc,gpropc,lpropd,gpropd,n)==1)
	          {
       	               acc=exp(lambdaL*infper)-1;
		       /*acc = mgf((-1.0d0)*lambdaL)-1*/
	               acc = acc*(Nllinks-sum(dl,n))/(sum(dl,n)+1); 
	               u=randomInteger01();
	               if(u<acc)
                       {    
	                    award(dl,dg,cg,cl,lpropd,gpropd,gpropc,lpropc,n,m);
		       }
		  } 
             }		
             else if((sum(dg,n))<n*(n-1))  /*Choose to add a global edge*/
	     {
		  /*pick a random vertex to add an edge to*/
		  i=randomIntegern(n*(n-1)-(sum(dg,n)));
		  j=1;
		  k=0;
	          do
		  {
		       k=k+(n-1)-dg[j];
    		       j=j+1;
		  }
		  while (k+(n-1)-dg[j]<i);    /*pick a random vertex to link to*/
		  do
                  {	
		       done=true; 
     		       k=randomIntegern(n);
		       if((k==j)||(dg[j]==n-1))
		       {
			    done=false;
		       }
		       else if(dg[j]>=1)
		       {
			    for(i=0; i<dg[j]; i++)
			    {
				 if(cg[j][i]==k)   
				 {
				      done=false;
				 }
			    }    
		       }		
                  }while(done==false);
                                     /*Set up the proposed new graph*/    
	          award(lpropd,gpropd,gpropc,lpropc,dl,dg,cg,cl,n,m);          

		  gpropd[j] = gpropd[j] +1;        /*Register the extra link*/
 	 	  gpropc[j][dg[j]+1] =k;            /*Draw the extra link*/
		  if (check(lpropc,gpropc,lpropd,gpropd,n)==1)
                  {
		       acc=exp(lambdaG*infper/(pop)) -1;
		       acc=acc*((n*(n-1))-(sum(dg,n)))/(sum(dg,n)+1);
		       u=randomInteger01();
		       if(u<acc)
                       {    
			    award(dl,dg,cg,cl,lpropd,gpropd,gpropc,lpropc,n,m);
                       }
                  }     
             }
        }    
        else if(p==2)   /*Delete an edge*/
	{
	     up=randomInteger01();
	     if((up<cholprob) && sum(dl,n)>0)  /*Choose to delete local*/
	     {
                  i=randomIntegern(sum(dl,n));     /*pick a random edge*/
		  j=orio[0]+1;
		  k=0;     /*No point to delete local edges from households of size 1*/
		  do
		  {
		       k=k+dl[j];
    	               j=j+1;
		  }while (k+dl[j]<i);
		  k=i -k; 
		  award(lpropd,gpropd,gpropc,lpropc,dl,dg,cg,cl,n,m); 
	          if (k<dl[j])
		  {
		       for(i=k; i<dl[j]-1; i++) 
 		       {
			    lpropc[j][i]= lpropc[j][i+1];
		       }
		  }
 		  lpropc[j][dl[j]]=0;
 		  loglikelihood(numer,lambdaL,lambdaG,gpropc,lpropc,lpropd,gpropd,grsize,n,pop);
		  if (numer[1]==1)
 	 	  {
		       loglikelihood(denom,lambdaL,lambdaG,cg,cl,dl,dg,grsize,n,pop);
		       acc= numer[0] -denom[0];
		       u=randomInteger01();
  		       if (log(u)<acc)            /*Update Graph*/
  		       {   
                            award(dl,dg,cg,cl,lpropd,gpropd,gpropc,lpropc,n,m);    
                       }
		  }
             }		    
             else if(sum(dg,n)>(sumdat-1))   /*Choose global*/
             {
	 	  i=randomIntegern(sum(dg,n));  /* pick a random edge*/
		  j=1;
  		  k=0;
  		  do
		  {
		       k=k+dg[j];
  		       j=j+1;
		  }while(k+dg[j]<i);
		  k=i-k;
		  award(lpropd,gpropd,gpropc,lpropc,dl,dg,cg,cl,n,m); 
		  if (k<dg[j])
		  {
		       for(i=k; i<dg[j]-1; i++)
		       {
	                    gpropc[j][i]= gpropc[j][i+1];
 		       }
		  }
   		  gpropc[j][dg[j]]=0;
 		  gpropd[j]=gpropd[j]-1;
	          loglikelihood(numer,lambdaL,lambdaG,lpropc,gpropc,lpropd,gpropd,grsize,n,pop);
 	          if(numer[1]==1)
		  {
	               loglikelihood(denom,lambdaL,lambdaG,cl,cg,dl,dg,grsize,n,pop);
 		       acc=numer[0]-denom[0];
		       u=randomInteger01();
 		       if ((log(u))<acc)
		       {	
		            award(dl,dg,cg,cl,lpropd,gpropd,gpropc,lpropc,n,m);
		       }
  		   }
             }
        }      
        if ((counter>0) && (counter%samgap==0)) 
        {
        }
             
        
   }      
   fclose(fd);
   for (i=0; i<n; i++)  /*first free each of the vector c[gi] */
        free(cg[i]);
    free(cg);             /*and finally the vector of vectors cg*/
    
   for (i=0; i<n; i++)  
        free(cl[i]);
    free(cl);

   for (i=0; i<n; i++)  
        free(gpropc[i]);
    free(gpropc);             
    
   for (i=0; i<n; i++)  
        free(lpropc[i]);
    free(lpropc); 

    free(linf);
    free(orio);
    free(dg);             /*free dg and propd*/ 
    free(dl);            
    free(gpropd);  
    free(lpropd);
    free(grsize);



    return (0);
}
             
   
/* the end of program start of function */
/* oi fanction einai oi parakatw        */


int randomInteger(void)
{
    int k;
    double number;
    
    /* Generate a random integer number sto(1,2) */
    number = (double)rand()/((double) RAND_MAX+1);
    k=(int)(number*2);
    return (k+1);
}

int randomIntegern(int n)
{
    int k;
    double number;
    
    /* Generate a random integer number sto(1,n) */
    number = (double)rand()/((double) RAND_MAX+1);
    k=(int)(number*n);
    return (k+1);
}

/* epistrefei apo mia omoiomorfh se [0,1] */

double randomInteger01(void)
{
    double number;
    
    number = (double)rand()/((double) RAND_MAX+1);
    return (number);
}

double randn (double mu, double sigma)
{
    double U1, U2, W, mult;
    static double X1, X2;
    static int call = 0;
    
    if (call == 1)
    {
        call = !call;
        return (mu + sigma * (double) X2);
    }
    
    do
    {
        U1 = -1 + ((double) rand () / RAND_MAX) * 2;
        U2 = -1 + ((double) rand () / RAND_MAX) * 2;
        W = pow (U1, 2) + pow (U2, 2);
    }
    while (W >= 1 || W == 0);
    
    mult = sqrt ((-2 * log (W)) / W);
    X1 = U1 * mult;
    X2 = U2 * mult;
    
    call = !call;
    
    return (mu + sigma * (double) X1);
}

void loglikelihood(double *result,int lamdaL,int lamdaG,int **lpropc,int **gpropc,int*ldegree,int*gdegree,int *locsize,int n,int pop)
{
     double llike1,sum,sum6,sum7,sum8,sum9,I=1,total;
     int llike2,i;
     llike1=0;    /*arxikopoihsh */
     llike2=0;
     total=0;
     if(check(lpropc,gpropc,ldegree,gdegree,n)==1)
     {
	for(i=0; i<n; i++)   /*gia kathe individual*/
	{
		sum6=(log(1-exp((-1)*lamdaL*I))*ldegree[i]);      
		sum7=(log(1-exp((-1)*lamdaG*(I)/pop))*gdegree[i]);
		sum8=((-1)*lamdaL*(I))*(locsize[i]-ldegree[i]-1);
  		sum9=((-1)*lamdaG*(I)/pop)*(pop-gdegree[i]-1);
		sum=sum6+sum7+sum8+sum9;
		total=total+sum;
	}
        llike1=total;
     }
     result[0]=llike1;   /*return the value of the likelihood if calculated*/
     result[1]=llike2;
}


int check(int **lpropc,int **gpropc,int *ldegree ,int *gdegree,int n)
{
    int checkout,i,*hit;
    
    hit=(int *) malloc(n*sizeof(int));
    
    for(i=0; i<n; i++)   /* */
    {
        hit[i]=0;
    }
    hit[6]=1;
    dohits(lpropc,gpropc,ldegree,gdegree,7,n,hit);
    if(sum(hit,n)==n)
    {
        checkout=1;
    }
    else
    {
        checkout=0;
    }
    
    free(hit);
    
    return checkout;
}
		
/* Function to check validity of infection pathway */
void dohits(int **lpropc,int **gpropc,int *ldegree,int *gdegree,int start,int n,int *hit)
{
    int i;
    if(gdegree[start-1]>0)
    {
        for(i=0; i<gdegree[start-1]; i++)  
        {
            if(hit[gpropc[start-1][i]-1]==0)  /* Look for global hits */
            {
                hit[gpropc[start-1][i]-1]=1;
                dohits(lpropc,gpropc,ldegree,gdegree,gpropc[start-1][i],n,hit); 
            }
        }
    }
    if(ldegree[start-1]>0)
    {
        for(i=0; i<ldegree[start-1]; i++)  
        {                               /* Look for local hits */
            if(hit[lpropc[start-1][i]-1]==0)  
            {
                hit[lpropc[start-1][i]-1]=1;
                dohits(lpropc,gpropc,ldegree,gdegree,lpropc[start-1][i],n,hit); 
            }
        }
    }
}




/* We calculate choose(n,k) using the formula product(from i=1 to k of (n+1-i)/i) which is more computationaly efficient than using the factorial
 + factorial(n) will break out if n is big
 we also calculate choose(n,n-k) if k>n/2 as it is quicker and choose is symetrical*/
long int choose(int n,int k)
{
    double result;
    int i;
    
    if(k>n) return(0);
    
    if(k>n/2) k=n-k;
    
    result=1;
    for(i=1;i<=k;i++)
        result*=(double)(n+1-i)/(i);
    
    return ((long int) result);
}

/* athrisma enos pinaka array */

int sum(int *pa, int num_elements)
{
    int i, sum1=0;
    for (i=0; i<num_elements; i++)
    {
        sum1 = sum1 + pa[i];
    }
    return(sum1);
}

void award(int*A,int*B,int**C,int**D,int*A2,int*B2,int**C2,int**D2,int n,int m)
{
    int i,j;
    for(i=0; i<n; i++)           
	{
	  A[i]=A2[i];
	  B[i]=B2[i];  
      	      for(j=0; j<n; j++)
              {
            	   C[i][j]=C2[i][j];  /*(nxn)*/
              }
	      for(j=0; j<m; j++)
	      {
	      	   D[i][j]=D2[i][j]; 
	      }
         }
}



/* Calculates the log-product of two gamma-density ratios
 f(x1)*f(x2)/(f(y1)*f(y2)) where lamb and ni are very 
 small to give a diffuse prior,here lamb=ni=0.0001*/


double gamratio(double x1,double x2,double y1,double y2)
{
  double ratio,lamb=0.0001,ni=0.0001;
  ratio=(lamb*(y1+y2-x1-x2))*((ni-1)*(log(x1*x2)-log(y1*y2)));
  return(ratio);
}

/*        

void allocate_mem(int*** arr, int n, int m)
{
  *arr = (int**)malloc(n*sizeof(int*));
  for(int i=0; i<n; i++)
    (*arr)[i] = (int*)malloc(m*sizeof(int));
} 

allocate_mem(&arr,n,m); 
*/

